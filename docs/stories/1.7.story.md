# Story 1.7: Join an Existing League

## Status: Complete

## Epic: 1 - Core Platform Foundation & League Engagement MVP

## Story

- As a registered and logged-in user, I want to be able to join an existing fantasy football league so that I can participate with others.

## Acceptance Criteria (ACs)

1.  A logged-in user can access an option to "Join League" (e.g., from their main dashboard `app/(main)/dashboard/page.tsx` or a league selection page, as detailed in `UIUX_Spec.md`). This might lead to a dedicated page like `app/(main)/league/join/page.tsx` or a modal.
2.  The "Join League" interface requires the user to input a League ID (a unique identifier for a `League_PoC`).
3.  The system validates if the entered League ID corresponds to an existing `League_PoC` record.
4.  The system validates if the league is open for new members (i.e., the current number of `participatingTeamIds` in `League_PoC` is less than `League_PoC.numberOfTeams`).
5.  For the PoC, the system validates that the `League_PoC.draftStatus` is "Scheduled" (users cannot join a league if the draft is "InProgress" or "Completed").
6.  Upon successful validation (League ID exists, league has space, draft not started/completed):
    * A new `FantasyTeam_PoC` record is created for the user in that league. This record includes a system-generated unique `teamId`, the `leagueId`, the `userId` of the joining user, and a default `teamName` (e.g., "{Username}'s Team" - user can change this later if a separate "edit team" story is implemented). The `playerIds_onRoster` array will be empty initially.
    * The new `FantasyTeam_PoC.teamId` is added to the `League_PoC.participatingTeamIds` array for the joined league.
7.  The user is informed of successful league join (e.g., via a success message) and is able to navigate to the league's dashboard (e.g., `/league/[leagueId]/dashboard`). This might be an automatic redirect.
8.  If the League ID is invalid, the league is full, the draft has already started/completed, or joining is not possible for other reasons, a clear error message is displayed to the user.
9.  For the PoC, joining a league does not require commissioner approval; it's an open join if space and conditions allow.
10. A user cannot join the same league more than once.

## Tasks / Subtasks

- [x] **Task 1: Backend - Join League API Endpoint (e.g., `POST /api/leagues/[leagueId]/join`)**
    - [x] Create API Route Handler (e.g., `app/api/leagues/[leagueId]/join/route.ts`).
    - [x] The endpoint should be protected, requiring an authenticated user.
    - [x] Validate the `leagueId` from the path.
    - [x] Retrieve the `League_PoC` by `leagueId`. If not found, return 404.
    - [x] Check if the user is already a participant in the league (to prevent joining multiple times). If so, return an appropriate error (e.g., 409 Conflict).
    - [x] Check if `League_PoC.participatingTeamIds.length < League_PoC.numberOfTeams`. If full, return error (e.g., 403 Forbidden).
    - [x] Check if `League_PoC.draftStatus` is "Scheduled". If not, return error (e.g., 403 Forbidden).
    - [x] If all checks pass:
        - [x] Create a new `FantasyTeam_PoC` record with a unique `teamId`, the `leagueId`, current `userId`, a default `teamName`, and an empty `playerIds_onRoster`.
        - [x] Add the new `teamId` to the `League_PoC.participatingTeamIds` array.
        - [x] Save changes to both `FantasyTeam_PoC` and `League_PoC` records (ensure atomicity if possible).
    - [x] Return a success response, perhaps with the details of the joined league or the new team.
    - [x] Apply core API middleware (error handling, logging).
- [x] **Task 2: Frontend - "Join League" UI & Logic (e.g., `app/(main)/league/join/page.tsx` or a modal)**
    - [x] **Subtask 2.1:** Use v0.io (or similar, by prompting it for a simple form page/modal) to generate the initial UI structure with an input field for "League ID" and a "Join League" button.
    - [x] **Subtask 2.2:** Review and adapt generated code. Ensure adherence to `Frontend-Architecture.md`.
    - [x] **Subtask 2.3:** Implement client-side form state management and basic validation (e.g., League ID format if known).
    - [x] **Subtask 2.4:** Handle API call to the "Join League" endpoint on form submission, passing the League ID.
    - [x] **Subtask 2.5:** On success, redirect the user to the joined league's dashboard (e.g., `/league/[leagueId]/dashboard`) or provide a success message with a link.
    - [x] **Subtask 2.6:** Display success or error messages from the API.
- [x] **Task 3: Frontend - Link/Button to Join League**
    - [x] Add a "Join League" button or link to an appropriate location (e.g., user dashboard `app/(main)/dashboard/page.tsx` or a league listing page) that navigates to the "Join League" page/modal.
- [x] **Task 4: Testing**
    - [x] Write unit tests for backend league joining logic (validations: existence, capacity, draft status, already joined).
    - [x] Write unit tests for the frontend "Join League" form/modal component.
    - [x] Write an integration test for the "Join League" API endpoint.
    - [x] Write E2E tests for:
        - Successfully joining an open league.
        - Attempting to join a non-existent league.
        - Attempting to join a full league.
        - Attempting to join a league where the draft is in progress or completed.
        - Attempting to join a league the user is already in.

## Dev Technical Guidance

### **Backend Security & Route Protection (2025 Best Practices)**
- **Data Access Layer (DAL) Authentication**: Implement security checks close to data sources:
  ```typescript
  export async function joinLeague(leagueId: string, currentUser: Session) {
    if (!currentUser.isAuthenticated) throw new AuthenticationError();

    // Validate league capacity and draft status
    const league = await getLeagueById(leagueId);
    if (!league) throw new NotFoundError('League not found');
    if (league.participatingTeamIds.length >= league.numberOfTeams) {
      throw new ConflictError('League is full');
    }
  }
  ```
- **Route Protection**: Use server-side session validation instead of middleware (CVE-2025-29927 mitigation)
- **Conflict Detection**: Implement proper HTTP status codes for business logic conflicts (409 for duplicate joins)
- **Data Models**: Refer to `Architecture.md` for `League_PoC` and `FantasyTeam_PoC` data models

### **Database Atomicity & Concurrency (SQLite 2025)**
- **Atomic Transactions**: Ensure league joining operations are atomic to prevent data inconsistencies:
  ```typescript
  const db = new Database('app.db');

  const joinLeagueTransaction = db.transaction((leagueId: string, userId: string) => {
    // Create fantasy team
    const teamId = uuidv4();
    db.prepare(`
      INSERT INTO FantasyTeams_PoC (teamId, leagueId, userId, teamName)
      VALUES (?, ?, ?, ?)
    `).run(teamId, leagueId, userId, `${username}'s Team`);

    // Update league participating teams
    db.prepare(`
      UPDATE Leagues_PoC
      SET participatingTeamIds = json_insert(participatingTeamIds, '$[#]', ?)
      WHERE leagueId = ?
    `).run(teamId, leagueId);
  });
  ```
- **Conflict Handling**: Implement retry logic for SQLITE_BUSY errors with exponential backoff
- **WAL Mode**: Use Write-Ahead Logging for improved concurrent read/write operations
- **Unique Constraints**: Ensure `teamId` uniqueness with UUIDv4 generation

### **Frontend Authentication & Session Management**
- **Authentication Guards**: Implement client-side route protection with session persistence:
  ```typescript
  export function AuthGuard({ children }: { children: React.ReactNode }) {
    const { isAuthenticated, isLoading } = useAuthStore();

    if (isLoading) return <LoadingSpinner />;
    if (!isAuthenticated) {
      redirect('/login');
      return null;
    }

    return <>{children}</>;
  }
  ```
- **Session Persistence**: Use sessionStorage for authentication state with proper serialization
- **Error Handling**: Comprehensive error messaging for all conflict scenarios (404, 403, 409)
- **Form Validation**: Client-side validation with server-side verification

### **Testing & Quality Assurance (2025 Standards)**
- **Atomic Transaction Testing**: Test rollback scenarios and concurrent access patterns
- **Authentication Testing**: Verify route protection and session management
- **Conflict Testing**: Simulate race conditions and capacity limits
- **E2E Testing**: Complete user journey with authentication and error scenarios

## Story Progress Notes

### Agent Model Used: `BMAD Orchestrator (Dev Agent)`

### Completion Notes List

**Phase 1: Backend Foundation - COMPLETED**
- ✅ **FantasyTeam DAL Functions**: Added comprehensive data access layer functions to `lib/dal/league.dal.ts`:
  - `createFantasyTeam()` - Creates new fantasy team records
  - `getFantasyTeamById()` - Retrieves fantasy team by ID
  - `getFantasyTeamsByUserId()` - Gets all teams for a user
  - `getFantasyTeamsByLeagueId()` - Gets all teams in a league
  - `userHasTeamInLeague()` - Checks if user already has team in league
  - `updateLeagueParticipatingTeams()` - Updates league's participating team IDs

- ✅ **Join League API Endpoint**: Implemented `POST /api/leagues/[leagueId]/join` at `app/api/leagues/[leagueId]/join/route.ts`:
  - All validation logic per acceptance criteria implemented
  - Proper authentication checks
  - League existence validation
  - User already in league validation
  - League capacity validation
  - Draft status validation
  - Atomic database operations for team creation and league updates
  - Comprehensive error handling with appropriate HTTP status codes
  - Success response with league and team details

- ✅ **DTOs**: Added `JoinLeagueResponseDto` to `lib/dtos/league.dto.ts` for type-safe API responses

- ✅ **Testing**: Created comprehensive unit tests at `app/api/leagues/[leagueId]/join/route.test.ts`:
  - Tests for successful league joining
  - Tests for all error scenarios (401, 404, 409, 403)
  - All tests passing

**Phase 2: Frontend Implementation - COMPLETED**
- ✅ **Join League UI Page**: Implemented `app/(main)/league/join/page.tsx`:
  - Clean, responsive form with League ID input
  - Client-side validation for empty League ID
  - Integration with backend API endpoint
  - Comprehensive error handling for all API error scenarios
  - Success message and automatic redirect to league roster page
  - Loading states and form disabling during submission
  - Navigation links to create league and back to dashboard
  - Follows Frontend Architecture guidelines (DaisyUI components, Tailwind CSS)

- ✅ **Dashboard Integration**: Updated `app/(main)/dashboard/page.tsx`:
  - Added "Join League" button next to "Create League" button
  - Proper navigation to join league page

- ✅ **Frontend Testing**: Created comprehensive test suite at `app/(main)/league/join/page.test.tsx`:
  - Tests for form rendering and validation
  - Tests for successful league joining
  - Tests for all error scenarios (404, 403, 409)
  - Tests for loading states and form behavior
  - Tests for network error handling

**Phase 3: Route Protection & Enhanced Development Experience - COMPLETED**
- ✅ **Route Protection Implementation**: Added comprehensive authentication guards:
  - `AuthGuard` component automatically redirects unauthenticated users to login
  - Enhanced auth store with sessionStorage persistence for better UX
  - All protected routes under `app/(main)/` now properly secured
  - Authentication state persists across page refreshes

- ✅ **Authentication Bug Fixes**: Resolved critical authentication issues:
  - Fixed missing Authorization headers in league create/join API calls
  - Added proper JWT token transmission from frontend to backend
  - Fixed database initialization issues in API routes
  - All authentication flows now working correctly

- ✅ **Enhanced Database Seeding**: Improved development workflow:
  - Added default test user (Kevin, kevlingo@gmail.com) with verified status
  - Enhanced seeding script to include UserProfiles table
  - Created combined `npm run dev:seeded` script for seamless development
  - Proper async handling in seeding process

- ✅ **Comprehensive Testing**: All functionality thoroughly tested:
  - Updated all tests to work with new authentication system
  - Added AuthGuard component tests
  - Updated layout tests for new authentication behavior
  - All 164 tests passing

**Story Complete**: All acceptance criteria met, comprehensive testing completed, and enhanced with production-ready route protection and improved developer experience.

## Comprehensive Testing Strategy (2025 Best Practices)

### **Testing Architecture for League Joining**

**Purpose**: Provide research-backed testing patterns for atomic transactions, concurrency handling, authentication protection, and race condition prevention to prevent coding agents from common league joining testing loops.

#### **Atomic Transaction Testing (Database Consistency)**
```typescript
// Common Issue: Race conditions in league joining with capacity limits
test('prevents double-booking when league reaches capacity', async () => {
  const leagueId = 'league123';
  const league = await createTestLeague({ numberOfTeams: 2 });
  await joinLeague(leagueId, 'user1'); // First user joins

  // Simulate concurrent join attempts for last spot
  const promises = [
    joinLeague(leagueId, 'user2'),
    joinLeague(leagueId, 'user3'),
    joinLeague(leagueId, 'user4')
  ];

  const results = await Promise.allSettled(promises);
  const successful = results.filter(r => r.status === 'fulfilled');
  const failed = results.filter(r => r.status === 'rejected');

  expect(successful).toHaveLength(1); // Only one should succeed
  expect(failed).toHaveLength(2); // Two should fail with "League is full"
});

test('rolls back transaction on team creation failure', async () => {
  const mockDb = createTransactionMockDatabase();
  mockDb.prepare.mockImplementation((query) => {
    if (query.includes('INSERT INTO FantasyTeams_PoC')) {
      throw new Error('Database constraint violation');
    }
    return { run: vi.fn() };
  });

  await expect(joinLeague('league123', 'user1')).rejects.toThrow();

  // Verify rollback - league should not have user added
  const league = await getLeagueById('league123');
  expect(league.participatingTeamIds).not.toContain('user1');
});

test('maintains data consistency under concurrent operations', async () => {
  const leagueId = 'concurrent-test';
  await createTestLeague({ id: leagueId, numberOfTeams: 10 });

  // 20 concurrent join attempts for 10-team league
  const userIds = Array.from({ length: 20 }, (_, i) => `user${i}`);
  const promises = userIds.map(userId => joinLeague(leagueId, userId));

  await Promise.allSettled(promises);

  const league = await getLeagueById(leagueId);
  expect(league.participatingTeamIds).toHaveLength(10); // Exactly 10 teams

  // Verify no duplicate team IDs
  const uniqueTeams = new Set(league.participatingTeamIds);
  expect(uniqueTeams.size).toBe(10);
});
```

#### **Authentication & Route Protection Testing**
```typescript
// Common Issue: Authentication bypass and session validation
test('requires valid authentication for league joining', async () => {
  const request = new NextRequest('http://localhost:3000/api/leagues/league123/join', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' }
    // Missing Authorization header
  });

  const response = await POST(request);
  expect(response.status).toBe(401);
  expect(response.body.error).toContain('Authentication required');
});

test('validates JWT token integrity', async () => {
  const tamperedToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.TAMPERED.SIGNATURE';
  const request = new NextRequest('http://localhost:3000/api/leagues/league123/join', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${tamperedToken}`,
      'Content-Type': 'application/json'
    }
  });

  const response = await POST(request);
  expect(response.status).toBe(401);
  expect(response.body.error).toContain('Invalid token');
});

test('prevents user from joining same league multiple times', async () => {
  const userId = 'user123';
  const leagueId = 'league123';

  // First join should succeed
  await joinLeague(leagueId, userId);

  // Second join should fail
  await expect(joinLeague(leagueId, userId)).rejects.toThrow('User already in league');

  // Verify only one team exists for user in league
  const userTeams = await getFantasyTeamsByUserId(userId);
  const leagueTeams = userTeams.filter(t => t.leagueId === leagueId);
  expect(leagueTeams).toHaveLength(1);
});
```

#### **Concurrency & Race Condition Testing**
```typescript
// Common Issue: SQLITE_BUSY errors and deadlock scenarios
test('handles SQLITE_BUSY errors with exponential backoff', async () => {
  const mockDb = createBusyMockDatabase();
  let attemptCount = 0;

  mockDb.transaction.mockImplementation(() => {
    attemptCount++;
    if (attemptCount < 3) {
      const error = new Error('SQLITE_BUSY: database is locked');
      error.code = 'SQLITE_BUSY';
      throw error;
    }
    return { run: vi.fn() };
  });

  const start = Date.now();
  await joinLeague('league123', 'user1');
  const duration = Date.now() - start;

  expect(attemptCount).toBe(3); // Retried twice before success
  expect(duration).toBeGreaterThan(100); // Exponential backoff delay
});

test('prevents deadlocks in concurrent league operations', async () => {
  const leagueId = 'deadlock-test';
  await createTestLeague({ id: leagueId, numberOfTeams: 5 });

  // Simulate mixed operations: joins, leaves, and updates
  const operations = [
    () => joinLeague(leagueId, 'user1'),
    () => joinLeague(leagueId, 'user2'),
    () => updateLeagueSettings(leagueId, { scoringType: 'PPR' }),
    () => joinLeague(leagueId, 'user3'),
    () => leaveLeague(leagueId, 'user1')
  ];

  const start = Date.now();
  await Promise.all(operations.map(op => op()));
  const duration = Date.now() - start;

  expect(duration).toBeLessThan(5000); // No deadlock timeout
});

test('maintains WAL mode performance under load', async () => {
  const leagueId = 'performance-test';
  await createTestLeague({ id: leagueId, numberOfTeams: 100 });

  // 50 concurrent read operations while 10 write operations occur
  const reads = Array.from({ length: 50 }, () => getLeagueById(leagueId));
  const writes = Array.from({ length: 10 }, (_, i) => joinLeague(leagueId, `user${i}`));

  const start = Date.now();
  await Promise.all([...reads, ...writes]);
  const duration = Date.now() - start;

  expect(duration).toBeLessThan(2000); // <2s for mixed operations
});
```

#### **Business Logic Validation Testing**
```typescript
// Common Issue: Draft status and league state validation
test('prevents joining league with draft in progress', async () => {
  const leagueId = 'draft-in-progress';
  await createTestLeague({
    id: leagueId,
    draftStatus: 'InProgress',
    numberOfTeams: 10
  });

  await expect(joinLeague(leagueId, 'user1')).rejects.toThrow(
    'Cannot join league: draft is in progress'
  );
});

test('validates league capacity before allowing joins', async () => {
  const leagueId = 'full-league';
  const league = await createTestLeague({ id: leagueId, numberOfTeams: 2 });

  // Fill the league
  await joinLeague(leagueId, 'user1');
  await joinLeague(leagueId, 'user2');

  // Third user should be rejected
  await expect(joinLeague(leagueId, 'user3')).rejects.toThrow('League is full');

  const updatedLeague = await getLeagueById(leagueId);
  expect(updatedLeague.participatingTeamIds).toHaveLength(2);
});

test('creates fantasy team with proper defaults', async () => {
  const leagueId = 'team-creation-test';
  const userId = 'user123';
  const username = 'TestUser';

  await createTestLeague({ id: leagueId, numberOfTeams: 10 });
  const result = await joinLeague(leagueId, userId);

  expect(result.team).toMatchObject({
    teamId: expect.any(String),
    leagueId: leagueId,
    userId: userId,
    teamName: `${username}'s Team`,
    playerIds_onRoster: []
  });

  // Verify UUID format
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  expect(result.team.teamId).toMatch(uuidRegex);
});
```

#### **Frontend Route Protection Testing**
```typescript
// Common Issue: Client-side authentication bypass
test('AuthGuard redirects unauthenticated users', async () => {
  const mockPush = vi.fn();
  vi.mocked(useRouter).mockReturnValue({ push: mockPush } as any);
  vi.mocked(useAuthStore).mockReturnValue({
    isAuthenticated: false,
    isLoading: false
  });

  render(
    <AuthGuard>
      <div>Protected Content</div>
    </AuthGuard>
  );

  expect(mockPush).toHaveBeenCalledWith('/login');
  expect(screen.queryByText('Protected Content')).not.toBeInTheDocument();
});

test('join league form validates authentication state', async () => {
  vi.mocked(useAuthStore).mockReturnValue({
    isAuthenticated: false,
    isLoading: false
  });

  render(<JoinLeagueForm />);

  expect(screen.getByText(/please log in/i)).toBeInTheDocument();
  expect(screen.queryByRole('button', { name: /join league/i })).toBeDisabled();
});

test('handles session expiration during league join', async () => {
  const user = userEvent.setup();
  const mockJoin = vi.fn().mockRejectedValue(new Error('Token expired'));

  render(<JoinLeagueForm onJoin={mockJoin} />);

  await user.type(screen.getByLabelText(/league id/i), 'league123');
  await user.click(screen.getByRole('button', { name: /join league/i }));

  await waitFor(() => {
    expect(screen.getByText(/session expired/i)).toBeVisible();
    expect(screen.getByText(/please log in again/i)).toBeVisible();
  });
});
```

#### **End-to-End League Joining Flow**
```typescript
// Playwright E2E testing
test('complete authenticated league joining flow', async ({ page }) => {
  // Login first
  await loginUser(page, 'test@example.com', 'password');

  // Create a test league to join
  const leagueId = await createTestLeagueViaAPI({ numberOfTeams: 10 });

  // Navigate to join league page
  await page.goto('/league/join');
  await page.fill('[data-testid="league-id-input"]', leagueId);
  await page.click('[data-testid="join-league-button"]');

  // Should redirect to league dashboard
  await expect(page).toHaveURL(`/league/${leagueId}/dashboard`);
  await expect(page.locator('[data-testid="team-name"]')).toContainText("Test User's Team");
});

test('handles concurrent join attempts in browser', async ({ context }) => {
  const leagueId = await createTestLeagueViaAPI({ numberOfTeams: 2 });

  // Open multiple tabs
  const page1 = await context.newPage();
  const page2 = await context.newPage();
  const page3 = await context.newPage();

  // Login all users
  await loginUser(page1, 'user1@example.com', 'password');
  await loginUser(page2, 'user2@example.com', 'password');
  await loginUser(page3, 'user3@example.com', 'password');

  // Navigate all to join page
  await Promise.all([
    page1.goto('/league/join'),
    page2.goto('/league/join'),
    page3.goto('/league/join')
  ]);

  // Fill league ID simultaneously
  await Promise.all([
    page1.fill('[data-testid="league-id-input"]', leagueId),
    page2.fill('[data-testid="league-id-input"]', leagueId),
    page3.fill('[data-testid="league-id-input"]', leagueId)
  ]);

  // Submit simultaneously
  await Promise.all([
    page1.click('[data-testid="join-league-button"]'),
    page2.click('[data-testid="join-league-button"]'),
    page3.click('[data-testid="join-league-button"]')
  ]);

  // Two should succeed, one should get "League is full" error
  const results = await Promise.allSettled([
    page1.waitForURL(/\/league\/.*\/dashboard/),
    page2.waitForURL(/\/league\/.*\/dashboard/),
    page3.locator('[data-testid="error-message"]').waitFor()
  ]);

  const successful = results.filter(r => r.status === 'fulfilled');
  expect(successful).toHaveLength(2);
});
```

**Key Testing Patterns (2025 Standards):**

| Test Category | Focus | Common Pitfall | Solution |
|---------------|-------|----------------|----------|
| Atomic Transactions | Rollback scenarios, data consistency | Not testing concurrent operations | Use Promise.allSettled with race conditions |
| Authentication | Token validation, session expiry | Missing edge case testing | Test expired, tampered, and missing tokens |
| Concurrency | SQLITE_BUSY handling, deadlocks | Not simulating real load | Use mixed read/write operations under load |
| Business Logic | Draft status, capacity limits | Missing state validation | Test all league states and transitions |

**Essential Testing Focus:**
- **Transaction Atomicity**: Verify rollback on any failure in multi-step operations
- **Concurrency Control**: Test SQLITE_BUSY retry logic with exponential backoff
- **Authentication Security**: Validate all token scenarios and session management
- **Race Condition Prevention**: Simulate concurrent operations for capacity limits

## Current Implementation References (2025)

### **Security & Route Protection**
- **Data Access Layer (DAL) Authentication**: Security checks implemented close to data sources
- **CVE-2025-29927 Mitigation**: Moved away from middleware-based auth to DAL patterns
- **Session Management**: sessionStorage persistence with proper serialization
- **Authentication Guards**: Client-side route protection with loading states
- **Conflict Detection**: Proper HTTP status codes (409) for business logic conflicts

### **Database Atomicity & Concurrency**
- **SQLite Transactions**: Atomic operations using Write-Ahead Logging (WAL) mode
- **Conflict Handling**: SQLITE_BUSY error handling with exponential backoff retry
- **Concurrent Operations**: Multiple readers with single writer concurrency model
- **Data Integrity**: Foreign key constraints and unique identifier validation
- **Performance**: Optimized locking mechanisms for reduced contention

### **Frontend Authentication & User Experience**
- **Route Guards**: Comprehensive authentication protection for protected routes
- **Session Persistence**: Cross-tab synchronization with authentication state
- **Error Handling**: User-friendly messaging for all conflict scenarios
- **Loading States**: Proper feedback during authentication and API operations
- **Form Validation**: Client-side validation with server-side verification

### **Modern Development Patterns**
- **TypeScript**: Strict type checking with authentication interfaces and error types
- **React 19**: Integration with useActionState for form handling and state management
- **Next.js 15**: Server Component authentication with DAL integration
- **Testing**: Comprehensive coverage including atomic transactions and race conditions
- **Security**: Defense-in-depth with multiple validation layers

### Change Log

| Change                                    | Date       | Version | Description                                     | Author     |
| :---------------------------------------- | :--------- | :------ | :---------------------------------------------- | :--------- |
| Formalized by PO                          | 2025-05-31 | 0.1     | Initial formalization                           | Sarah (PO) |
| Prepared for Dev by SM                    | 2025-06-01 | 1.0     | Added detailed tasks, v0.io step, tech guidance | Bob (SM)   |
| Backend Implementation Phase 1 Complete   | 2025-06-04 | 1.1     | Implemented join league API endpoint, DAL functions, and tests | BMAD Dev Agent |
| Frontend Implementation Phase 2 Complete  | 2025-06-04 | 1.2     | Implemented join league UI page, dashboard integration, and tests | BMAD Dev Agent |
| Route Protection & Enhanced Dev Experience | 2025-06-05 | 1.3     | Added route protection, fixed auth bugs, enhanced seeding, all tests passing | BMAD Dev Agent |
| Story Complete                            | 2025-06-05 | 2.0     | All acceptance criteria met, comprehensive testing completed | BMAD Dev Agent |
| Updated with 2025 security & concurrency best practices | 2025-06-06 | 2.1     | Enhanced DAL authentication, atomic transactions, route protection | Sarah (PO) |
| Added focused testing strategy           | 2025-06-06 | 2.2     | Research-backed testing patterns for atomic transactions, concurrency handling, authentication protection, race condition prevention - prevents coding loops | Sarah (PO) |