# Story 2.3: Develop "Learn-As-You-Go" Mechanism for User Preference Profile Refinement

## Status: Approved

## Epic: 2 - AI Copilot Onboarding & Personalization Foundation MVP

## Story

- As an active user, I want the AI Copilot to observe my actions and decisions, and when it detects patterns or significant deviations from my current User Preference Profile, I want it to proactively ask for my confirmation to update and refine my profile so that its advice becomes increasingly personalized and accurate over time.

## Acceptance Criteria (ACs)

1.  The "AI Copilot Service" (backend logic within Next.js, as per `Architecture.md`) includes a mechanism to "observe" key user actions. For PoC, observed actions are simplified and might include:
    * Analysis of players drafted/added via waivers (e.g., if a user consistently picks players tagged with `keyAttributes.upsidePotential: "High"` when their `riskComfortLevel` is "low").
    * (PoC Stretch) Analysis of lineup choices against projections/risk (e.g., consistently starting high-risk players).
2.  The AI Copilot Service compares observed behaviors against the user's existing `UserProfile` (`selectedArchetype`, `onboardingAnswers`, `learnedObservations`).
3.  (PoC Scope) When a predefined, simplified pattern or deviation is detected (e.g., 2-3 consecutive high-risk waiver claims by a "low-risk" user), the AI Copilot Service generates a contextual refinement prompt.
4.  This refinement prompt is surfaced to the user unobtrusively via the `AIPanel.tsx` (from `UIUX_Spec.md` and v0.io prompt).
5.  The prompt clearly states the observation and asks for confirmation to update preferences (e.g., "I've noticed you've been making some bold waiver claims! Should I adjust your risk profile to consider more high-upside players?").
6.  The user can respond "Yes" / "No" (or similar) via interactive elements within the `AIPanel.tsx`.
7.  If "Yes": The AI Copilot Service (via an API call) updates the `UserProfile` (e.g., adding to `learnedObservations.playerStyleAffinity` or adjusting `riskComfortLevel` or a new numeric `riskToleranceNumeric` field).
8.  If "No": The `UserProfile` is not updated for that observation, and the AI respects this (e.g., by not prompting for the exact same observation too frequently).
9.  The AI Copilot provides brief confirmation of the user's choice within the `AIPanel.tsx`.
10. For PoC, the observation logic and pattern detection are simplified to 1-2 demonstrable scenarios triggered by actions within the static data environment.

## Tasks / Subtasks

- [ ] **Task 1: Backend - Design "Observation" Heuristics & Triggers (AI Copilot Service)**
    - [ ] Define 1-2 simple, detectable patterns for PoC (e.g., "User drafted/added X number of 'high-upside' players despite 'low-risk' profile setting").
    - [ ] Design how user actions (draft picks, waiver adds - from Story 1.8, 1.11 APIs) will be logged or made available to the AI Copilot Service for this analysis. (This might involve the AI Copilot Service itself inspecting team rosters after changes).
- [ ] **Task 2: Backend - Implement Pattern Detection & Prompt Generation (AI Copilot Service)**
    - [ ] Implement logic in AI Copilot Service to analyze relevant user data against their `UserProfile` to detect the defined patterns/triggers.
    - [ ] Implement logic to generate the appropriate refinement prompt text based on the detected pattern.
- [ ] **Task 3: Backend - API for Refinement Interaction**
    - [ ] Create an API endpoint (e.g., `GET /api/copilot/refinement-prompts`) for the frontend to fetch any pending refinement prompts for the user.
    - [ ] Create an API endpoint (e.g., `POST /api/copilot/refinement-response`) for the frontend to send the user's response (Yes/No and prompt ID). This endpoint will trigger the AI Copilot Service to update `UserProfile` if "Yes".
    - [ ] Apply core API middleware.
- [ ] **Task 4: Backend - Update UserProfile based on Response**
    - [ ] Implement logic in AI Copilot Service (triggered by `POST /api/copilot/refinement-response`) to update `UserProfile.learnedObservations` or other relevant preference fields based on an affirmative user response.
- [ ] **Task 5: Frontend - Display Refinement Prompts & Handle Responses (in `AIPanel.tsx`)**
    - [ ] **Subtask 5.1:** Modify `AIPanel.tsx` to periodically poll or fetch pending refinement prompts from `GET /api/copilot/refinement-prompts`.
    - [ ] **Subtask 5.2:** If prompts are available, display the current prompt text with "Yes" and "No" buttons. (UI for this interaction within the panel needs to be designed; v0.io might be prompted for a generic "message with action buttons" component).
    - [ ] **Subtask 5.3:** On user response, call `POST /api/copilot/refinement-response` with the response.
    - [ ] **Subtask 5.4:** Display confirmation message within the panel.
- [ ] **Task 6: Testing**
    - [ ] Unit tests for backend heuristic/pattern detection logic.
    - [ ] Unit tests for backend `UserProfile` update logic based on refinement responses.
    - [ ] Integration tests for `/api/copilot/refinement-prompts` and `/api/copilot/refinement-response` API endpoints.
    - [ ] E2E test:
        - [ ] User performs actions that trigger a defined heuristic (e.g., making several "high-risk" waiver adds).
        - [ ] Verify the refinement prompt appears in the AI Copilot Panel.
        - [ ] User responds "Yes," verify (e.g., via a test API or checking DB if possible for test) that `UserProfile` is updated.
        - [ ] User responds "No" to another prompt, verify profile is not updated.

- [ ] **Task 7: Build and Test Validation**
    - [ ] Build completed successfully with no errors
    - [ ] All tests passing (37 test suites, 301 tests passed)
    - [ ] Fixed NextResponse mocking issues in API tests
    - [ ] Component tests, unit tests, and integration tests all pass
    - [ ] Fixed syntax errors in component integration

- [ ] **Task 8: Story Completion**
    - [ ] All acceptance criteria met
    - [ ] Learn-As-You-Go mechanism observes user actions and detects patterns
    - [ ] AI Copilot proactively asks for confirmation to update user preferences
    - [ ] Proper loading states, error handling, and accessibility features implemented
    - [ ] Story marked as Complete following BMAD methodology

## Dev Technical Guidance

### **Behavioral Pattern Detection & Machine Learning (2025 Best Practices)**
- **Heuristic Algorithm Implementation**: Use efficient pattern detection with privacy-preserving analytics:
  ```typescript
  interface UserBehaviorPattern {
    userId: string;
    actionType: 'draft_pick' | 'waiver_claim' | 'lineup_change';
    playerAttributes: {
      riskLevel: 'low' | 'medium' | 'high';
      upsidePotential: number;
      consistencyRating: number;
    };
    timestamp: Date;
    confidence: number; // 0-1 confidence score
  }

  class BehaviorAnalyzer {
    detectRiskToleranceShift(actions: UserBehaviorPattern[], currentProfile: UserProfile): PatternDetection {
      const recentActions = actions.filter(a =>
        Date.now() - a.timestamp.getTime() < 7 * 24 * 60 * 60 * 1000 // 7 days
      );

      const riskScore = recentActions.reduce((acc, action) =>
        acc + (action.playerAttributes.riskLevel === 'high' ? 1 : 0), 0
      ) / recentActions.length;

      return {
        detected: riskScore > 0.6 && currentProfile.riskComfortLevel === 'conservative',
        confidence: Math.min(riskScore, 0.95),
        suggestedUpdate: { riskComfortLevel: 'balanced' }
      };
    }
  }
  ```
- **Privacy-Preserving Analytics**: Implement differential privacy for user behavior analysis without compromising personal data
- **Real-Time Pattern Recognition**: Use temporal attention models for sequential user action analysis
- **Federated Learning Approach**: Process user patterns locally to maintain privacy while improving global models

### **Interactive AI Feedback Systems & Real-Time Adaptation**
- **Conversational Interface Integration**: Implement adaptive AI feedback with React/TypeScript:
  ```typescript
  const AdaptiveAIPanel = () => {
    const [refinementPrompt, setRefinementPrompt] = useState<RefinementPrompt>();
    const [userFeedback, setUserFeedback] = useState<'pending' | 'accepted' | 'declined'>();

    const { data: prompts } = useQuery({
      queryKey: ['refinement-prompts'],
      queryFn: () => fetchRefinementPrompts(),
      refetchInterval: 30000, // Check every 30 seconds
      enabled: userFeedback !== 'pending'
    });

    const handleResponse = async (response: boolean) => {
      setUserFeedback('pending');
      await submitRefinementResponse(refinementPrompt.id, response);
      setUserFeedback(response ? 'accepted' : 'declined');
    };

    return (
      <div className="ai-panel" role="region" aria-label="AI Copilot Feedback">
        {refinementPrompt && (
          <div className="refinement-prompt">
            <p>{refinementPrompt.message}</p>
            <div className="action-buttons">
              <button onClick={() => handleResponse(true)} aria-label="Accept suggestion">
                Yes, update my preferences
              </button>
              <button onClick={() => handleResponse(false)} aria-label="Decline suggestion">
                No, keep current settings
              </button>
            </div>
          </div>
        )}
      </div>
    );
  };
  ```
- **Real-Time User Adaptation**: WebSocket integration for immediate feedback and profile updates
- **Contextual Memory**: Maintain conversation history for improved pattern recognition
- **Multi-Modal Feedback**: Support for voice, text, and gesture-based user responses

### **User Profiling & Preference Refinement**
- **Dynamic Profile Updates**: Implement incremental learning with confidence scoring:
  ```typescript
  interface LearnedObservation {
    category: 'risk_tolerance' | 'player_preference' | 'strategy_style';
    observation: string;
    confidence: number;
    timestamp: Date;
    validatedByUser: boolean;
  }

  const updateUserProfile = async (userId: string, observation: LearnedObservation) => {
    const profile = await getUserProfile(userId);

    // Add to learned observations with confidence weighting
    profile.learnedObservations.push(observation);

    // Update primary preferences if confidence is high and user validated
    if (observation.confidence > 0.8 && observation.validatedByUser) {
      switch (observation.category) {
        case 'risk_tolerance':
          profile.riskComfortLevel = deriveRiskLevel(observation);
          break;
        case 'player_preference':
          profile.playerStyleAffinity = updatePlayerPreferences(observation);
          break;
      }
    }

    await saveUserProfile(profile);
  };
  ```
- **Bias Mitigation**: Regular audits using fairness metrics to ensure equitable profiling
- **Explainable AI**: SHAP values for transparent decision-making in preference updates
- **Privacy Controls**: User-controlled data retention and deletion capabilities

### **Performance & Scalability (2025 Standards)**
- **Edge Computing**: Deploy lightweight ML models on user devices for real-time analysis
- **Efficient Heuristics**: Genetic algorithms for feature selection and pattern optimization
- **Caching Strategies**: Redis-based caching for frequently accessed user patterns
- **API Optimization**: Lightweight endpoints with sub-200ms response times for natural interaction flow

## Story Progress Notes

### Agent Model Used: `<To be filled by Dev Agent>`

### Completion Notes List

{To be filled by Dev Agent}

## Current Implementation References (2025)

### **Machine Learning & Behavioral Analysis**
- **Heuristic Algorithms**: Genetic algorithms for feature selection and temporal attention models for sequential analysis
- **Privacy-Preserving Analytics**: Differential privacy and federated learning for user behavior analysis
- **Pattern Detection**: Real-time recognition using confidence scoring and temporal pattern analysis
- **Bias Mitigation**: Regular fairness audits with demographic parity and explainable AI using SHAP values
- **Edge Computing**: Lightweight ML models deployed on user devices for real-time processing

### **Interactive AI Feedback Systems**
- **Conversational Interfaces**: React/TypeScript components with WebSocket integration for real-time adaptation
- **Contextual Memory**: Conversation history maintenance for improved pattern recognition
- **Multi-Modal Feedback**: Support for voice, text, and gesture-based user interactions
- **Adaptive UI**: Dynamic interface adjustments based on user behavior patterns and preferences
- **Response Time Optimization**: Sub-200ms API responses for natural interaction flow

### **User Profiling & Preference Refinement**
- **Dynamic Profile Updates**: Incremental learning with confidence scoring and user validation
- **Learned Observations**: Structured data model for capturing and validating user behavior patterns
- **Privacy Controls**: User-controlled data retention, deletion, and preference management
- **Profile Versioning**: Temporal tracking of preference changes with rollback capabilities
- **Validation Mechanisms**: User confirmation workflows for preference updates

### **Performance & Scalability**
- **Real-Time Processing**: WebSocket integration for immediate feedback and profile updates
- **Caching Strategies**: Redis-based caching for frequently accessed user patterns and preferences
- **API Optimization**: Lightweight endpoints with efficient data structures and minimal payload
- **Monitoring**: Real-time analytics for pattern detection accuracy and user engagement metrics
- **Accessibility**: WCAG 2.2 compliance for AI feedback interfaces and user interaction components

### Change Log

| Change                                    | Date       | Version | Description                                     | Author     |
| :---------------------------------------- | :--------- | :------ | :---------------------------------------------- | :--------- |
| Formalized by PO                          | 2025-05-31 | 0.1     | Initial formalization                           | Sarah (PO) |
| Prepared for Dev by SM                    | 2025-06-01 | 1.0     | Added detailed tasks and tech guidance          | Bob (SM)   |
| Updated with 2025 ML & behavioral analysis best practices | 2025-06-06 | 1.1     | Enhanced pattern detection, interactive AI, privacy-preserving analytics | Sarah (PO) |